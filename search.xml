<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小程序</title>
      <link href="/2023/12/03/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/12/03/%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="视图容器类组件"><a href="#视图容器类组件" class="headerlink" title="视图容器类组件"></a>视图容器类组件</h3><p><strong>常见的视图容器类组件：view，scroll-view，swiper和swiper-item</strong></p><p>view：普通视图，类似于div</p><p>scroll-view：可滚动的视图区域</p><p>​scroll-x属性：允许横向滚动，scroll-y：允许纵向滚动，允许数项滚动时，必须给scroll-view一个固定高度。</p><p>swiper和swiper-item:轮播视图容器组件和轮播图item组件</p><p>​                       <img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191929234.png" style="zoom:80%;" /></p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191930325.png" alt="image-20231125110046357"  /><p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191930753.png"></p><p><strong>常见的基础内容组件：text，rich-text</strong></p><p>text：文本组件，类似于HTML中的span标签，是一个行内元素。</p><p>只有text组件支持长按选中效果。</p><p>rich-text：富文本组件，支持把HTML字符串渲染为WXML结构。</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191930884.png" alt="image-20231125212716492" style="zoom:50%;" /><p><strong>其他常见组件：</strong></p><p>button：按钮组件，功能比HTML中的button按钮丰富，通过open-type属性可以调用微信提供的各种功能（客服，转发，获取用户授权，获取用户信息等）</p><p>image：图片组件，默认宽度为300px，高度约240px</p><p>navigator：页面导航组件，类似于html中的a链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;普通按钮&lt;/button&gt;</span><br><span class="line">&lt;button type=&quot;primary&quot;&gt;主色调按钮&lt;/button&gt;</span><br><span class="line">&lt;button type=&quot;warn&quot;&gt;警告按钮&lt;/button&gt;</span><br><span class="line">&lt;button type=&quot;default&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;button size=&quot;mini&quot;&gt;普通按钮&lt;/button&gt;</span><br><span class="line">&lt;button type=&quot;primary&quot; size=&quot;mini&quot;&gt;主色调按钮&lt;/button&gt;</span><br><span class="line">&lt;button type=&quot;warn&quot; size=&quot;mini&quot;&gt;警告按钮&lt;/button&gt;</span><br><span class="line">&lt;button type=&quot;default&quot; size=&quot;mini&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;button size=&quot;mini&quot; plain=&quot;true&quot;&gt;普通按钮&lt;/button&gt;</span><br><span class="line">&lt;button type=&quot;primary&quot; size=&quot;mini&quot; plain=&quot;true&quot;&gt;主色调按钮&lt;/button&gt;</span><br><span class="line">&lt;button type=&quot;warn&quot; size=&quot;mini&quot; plain=&quot;true&quot;&gt;警告按钮&lt;/button&gt;</span><br><span class="line">&lt;button type=&quot;default&quot; size=&quot;mini&quot; plain=&quot;true&quot;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191930639.png" alt="image-20231125214646346" style="zoom:67%;" /><p>image组件的mode属性用来指定图片的裁剪和缩放模式，常见的mode属性如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scaleToFill：（默认值）不保持纵横比缩放图片，使图片的宽高完全拉伸至填满image元素</span><br><span class="line">aspectFit：缩放模式，保持纵横比缩放图片，使图片的长边可以完全显示出来，也就是说，可以完整的将图片显示出来。</span><br><span class="line">aspectFill:缩放模式，保持纵横比缩放图片，只保持图片的短边能完全显示出来，也就是说，图片通常只在水平或垂直方向是完整的，另一个方向就会发生截断。</span><br><span class="line">widthFix：缩放模式，宽度不变，高度自动变化，保持原图宽高比不变</span><br><span class="line">heightFix：缩放模式，高度不变，宽度自动变化，保持原图宽高比不变</span><br><span class="line">&lt;image src=&quot;    &quot; mode=&quot;  &quot;&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure><p><strong>小程序API的三大分类：</strong></p><p>事件监听API，同步API，异步API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">事件监听API:</span><br><span class="line">以on开头，监听某些事件的触发</span><br><span class="line">wx.onWindowResize(function callback)监听窗口尺寸变化的事件</span><br><span class="line">同步API：</span><br><span class="line">以Sync结尾的API都是同步API</span><br><span class="line">同步API执行结果，可以通过函数返回值直接获取，如果执行错误会抛出异常</span><br><span class="line">wx.setStorageSync(&#x27;key&#x27;,&#x27;value&#x27;)向本地存储中写入内容</span><br><span class="line">异步API：</span><br><span class="line">类似于$.ajax(options)函数，需要通过success，fail，complete接收调用的结果</span><br><span class="line">wx.request()发起网络数据请求，通过success回调函数接收数据。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931040.png" alt="image-20231125224555893"></p><h2 id="WXML模板语法-数据绑定"><a href="#WXML模板语法-数据绑定" class="headerlink" title="WXML模板语法-数据绑定"></a>WXML模板语法-数据绑定</h2><p><strong>数据绑定的基本原则：</strong></p><p>在data里定义数据，在WXML中使用数据</p><p>Mustache语法:</p><p>应用场景：绑定内容，绑定属性，运算（三元运算，算术运算等）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**aaa.js**/动态绑定内容</span><br><span class="line">data: &#123;</span><br><span class="line">    //字符串类型的数据</span><br><span class="line">    info:&#x27;init data&#x27;,</span><br><span class="line">    //数组类型的数据</span><br><span class="line">    msList:[&#123;msg:&#x27;hello&#x27;&#125;,&#123;msg:&#x27;world&#x27;&#125;]</span><br><span class="line">  &#125;</span><br><span class="line">  ------------------------------------------</span><br><span class="line">  /**aaa.wxml**/</span><br><span class="line"> &lt;view&gt;&#123;&#123;info&#125;&#125;&lt;/view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**aaa.js**/动态绑定属性</span><br><span class="line">data: &#123;</span><br><span class="line">   imgSrc:&quot;/image/avatar.jpg&quot;</span><br><span class="line"> &#125;</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> &lt;image src=&quot;&#123;&#123;imgSrc&#125;&#125;&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> /**aaa.js**/三元运算</span><br><span class="line">data: &#123;</span><br><span class="line">   randomNum:Math.random()*10//生成10以内的随机数</span><br><span class="line"> &#125;</span><br><span class="line"> -----------------------------------------------</span><br><span class="line"> &lt;view&gt;&#123;&#123;randomNum &gt;=5 ? &#x27;随机数字大于等于5&#x27;:&#x27;随机数字小于5&#x27;&#125;&#125;&lt;/view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> /**aaa.js**/算术运算</span><br><span class="line">data: &#123;</span><br><span class="line">   randomNum:Math.random().toFixed(2)//生成带两位小数的随机数</span><br><span class="line"> &#125;</span><br><span class="line"> -----------------------------------------------</span><br><span class="line"> &lt;view&gt;生成100以内的随机数：&#123;&#123;randomNum*100&#125;&#125;&lt;/view&gt;</span><br></pre></td></tr></table></figure><p><strong>事件绑定：</strong></p><p>事件是渲染层（页面）到逻辑层（js）的通讯方式，通过事件可以将用户在渲染层产生的行为，由微信客户端反馈到逻辑层进行业务的处理。</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931047.png" alt="image-20231125235253318" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931579.png" alt="image-20231125235415353" style="zoom:80%;" /><p>target和currentTarget的区别：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931767.png" alt="image-20231125235807241" style="zoom:80%;" /><p>bindrap的语法格式：</p><p>不存在html里的onclick的点击事件，而是通过tap时间来响应用户的触摸行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  /**aaa.js**/</span><br><span class="line">  //定义按钮的事件处理函数</span><br><span class="line">  btnTapHandler(e)&#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">  --------------------------------------</span><br><span class="line">  &lt;!--事件绑定--&gt;</span><br><span class="line">&lt;button type=&quot;primary&quot; bindtap=&quot;btnTapHandler&quot;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>在事件处理函数中为data中的数据赋值</p><p>通过调用this.setData（dataObject）方法，可以给页面data中的数据重新赋值 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  data：&#123;</span><br><span class="line">  count：0</span><br><span class="line">&#125;</span><br><span class="line">  changeNum()&#123;</span><br><span class="line">    console.log(&#x27;ok&#x27;)</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      count:this.data.count+1</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">-------------------------------------------</span><br><span class="line">&lt;button type=&quot;primary&quot; bindtap=&quot;changeNum&quot;&gt;+1&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><strong>事件传参：</strong></p><p>小程序里的事件传参，不能在绑定事件的同时为事件处理函数传递参数，如bindtap&#x3D;“btnHandler（123）”就不对，会把bindtap的属性值统一当成事件名称处理，可以为组件提供data-*自定义属性传参，其中*****代表的是参数的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  btnTapHandler1(e)&#123;</span><br><span class="line">    //dataset是一个对象，包含了所有通过data-*传递过来的参数项</span><br><span class="line">  console.log(e.target.dataset),//&#123;info:2&#125;</span><br><span class="line">  //通过dataset可以访问到具体参数的值</span><br><span class="line">  console.log(e.target.dataset.info)//2</span><br><span class="line">  &#125;</span><br><span class="line">-----------------------------------------</span><br><span class="line">&lt;button  bindtap=&quot;btnTapHandler&quot; data-info=&quot;&#123;&#123;2&#125;&#125;&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">//info会被解析为参数的名字，数值2会被解析为参数的值。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>bindinput的语法格式：</strong></p><p>通过input事件来响应文本框的输入事件，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inputHandler(e)&#123;</span><br><span class="line">  //e.detail.value是变化之后文本框最新的值  </span><br><span class="line">console.log(e.detail.value)</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------</span><br><span class="line">&lt;input bindinput=&quot;inputHandler&quot;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure><p><strong>实现文本框和data之间的数据同步：</strong></p><p>实现步骤：定义数据，渲染结构，美化样式，绑定input事件处理函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>条件渲染：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用wx：if=&quot;&#123;&#123;condition&#125;&#125;&quot;来判断是否要渲染该代码块</span><br><span class="line">&lt;view wx:if=&quot;&#123;&#123;conditon&#125;&#125;&quot;&gt;true&lt;/view&gt;</span><br><span class="line">也可以用wx：elif和wx：else来添加else判断</span><br><span class="line">&lt;view wx:if=&quot;&#123;&#123;type===1&#125;&#125;&quot;&gt;男&lt;/view&gt;</span><br><span class="line">&lt;view wx:elif=&quot;&#123;&#123;type===2&#125;&#125;&quot;&gt;女&lt;/view&gt;</span><br><span class="line">&lt;view wx:else&gt;保密&lt;/view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结合&lt;block&gt;使用wx：if</span><br><span class="line">一次性控制多个组件的展示和隐藏，可以使用一个&lt;block&gt;&lt;/block&gt;标签将多个组件包装起来，并在&lt;block&gt;标签上使用wx：if控制属性</span><br><span class="line">注意：&lt;block&gt;并不是一个组件，只是一个包裹性质的容器，不会在页面中做任何渲染</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;view hidden=&quot;&#123;&#123;flag&#125;&#125;&quot;&gt;条件为true的时候隐藏元素，否则显示&lt;/view&gt;</span><br><span class="line">使用hidden=&quot;&#123;&#123;condition&#125;&#125;&quot;也能控制元素的显示与隐藏</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">wx：if和hidden的对比：</span><br><span class="line">1.运行方式不同</span><br><span class="line">wx：if以动态创建和移除元素的方式，控制元素的展示和隐藏</span><br><span class="line">hidden以切换样式的方式（display：none/block；），控制元素的显示与隐藏</span><br><span class="line">2.使用建议</span><br><span class="line">频繁切换时，建议使用hidden</span><br><span class="line">控制条件复杂时，建议使用wx：if搭配wx：elif，wx：else进行展示和隐藏的切换</span><br></pre></td></tr></table></figure><p><strong>列表渲染：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">array:[&#x27;苹果&#x27;,&#x27;华为&#x27;,&#x27;小米&#x27;]</span><br><span class="line">通过wx：for可以根据指定的数组，循环渲染重复的组件结构</span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;</span><br><span class="line">索引是：&#123;&#123;index&#125;&#125;当前项为：&#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">//索引是：0，item是：苹果</span><br><span class="line">//索引是：1，item是：华为</span><br><span class="line">//索引是：2，item是：小米</span><br><span class="line">默认情况下，当前循环项的索引用index表示，当前循环项用item表示</span><br><span class="line">手动指定索引和当前项的变量名*(了解)</span><br><span class="line">使用wx：for-index可以指定当前循环项的索引的变量名</span><br><span class="line">使用wx：for-item可以指定当前项的变量名 </span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;</span><br><span class="line">索引是：&#123;&#123;idx&#125;&#125; 当前项是：&#123;&#123;itemName&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">//索引是：0，item是：苹果</span><br><span class="line">//索引是：1，item是：华为</span><br><span class="line">//索引是：2，item是：小米</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wx：key的使用</span><br><span class="line">data：&#123;</span><br><span class="line">userlist:[</span><br><span class="line">&#123;id:1,name:&quot;小红&quot;&#125;,</span><br><span class="line">&#123;id:2,name:&quot;小黄&quot;&#125;,</span><br><span class="line">&#123;id:3,name:&quot;小白&quot;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;userlist&#125;&#125;&quot; wx:key=&quot;id&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt;</span><br><span class="line">//对于上面的arr1，可以使用wx:key=&quot;index&quot;</span><br></pre></td></tr></table></figure><h2 id="wxss模板样式"><a href="#wxss模板样式" class="headerlink" title="wxss模板样式"></a>wxss模板样式</h2><p>与css相比，wxss扩展的特性有：rpx尺寸单位，@import样式导入</p><p>rpx尺寸单位：微信小程序独有的，用来解决屏幕适配的尺寸单位。</p><p>实现原理：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx把所有设备的屏幕，在宽度上等分为750份，   9+在较小的设备上，1rpx所代表的宽度较小，在较大的设备上，1rpx所代表的宽度较大，在不同设备上运行，会自动把rpx的样式单位换算成对应的像素单位来渲染，从而实现屏幕适配</p><p>rpx和px之间的单位换算*</p><p>在iphone6上，屏幕宽度为375px，共有750个物理像素，等分为750px，750rpx&#x3D;375px&#x3D;750物理像素，1rpx&#x3D;0.5px&#x3D;1物理像素，1px&#x3D;2rpx，建议使用iPhone6作为视觉稿的标准，在iPhone6上要绘制宽100px，高20px的盒子，换算成rpx单位，宽高分别为200rpx和40rpx。</p><p><strong>样式导入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import后跟需要导入的外联样式表的相对路径，用;表示语句结束</span><br><span class="line">@import&quot;common.wxss&quot;;</span><br></pre></td></tr></table></figure><p><strong>全局样式和局部样式：</strong></p><p>定义在app.wxss中的样式为全局样式，作用于每一个页面，在页面的.wxss文件中定义的样式为局部样式，只作用于当前页面。注意：当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式，当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="property">wxss</span>中的</span><br><span class="line">view&#123;</span><br><span class="line"><span class="attr">color</span>:red</span><br><span class="line">&#125;权重（<span class="number">0</span>，<span class="number">0</span>，<span class="number">1</span>）</span><br><span class="line">aaa.<span class="property">wxss</span>中的</span><br><span class="line">view&#123;</span><br><span class="line"><span class="attr">color</span>:blue</span><br><span class="line">&#125;权重（<span class="number">0</span>，<span class="number">0</span>，<span class="number">1</span>），一样的，局部覆盖全局</span><br><span class="line">app.<span class="property">wxss</span>中的</span><br><span class="line">view：nth-<span class="title function_">child</span>(<span class="params"><span class="number">1</span></span>)&#123;</span><br><span class="line"><span class="attr">color</span>:yellow</span><br><span class="line">&#125;权重（<span class="number">0</span>，<span class="number">1</span>，<span class="number">1</span>）权重比局部的大，覆盖局部的</span><br></pre></td></tr></table></figure><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><h3 id="全局配置文件以及常用的配置项："><a href="#全局配置文件以及常用的配置项：" class="headerlink" title="全局配置文件以及常用的配置项："></a>全局配置文件以及常用的配置项：</h3><p>app.json是全局配置文件，常用配置如下：pages：记录当前小程序的所有页面的存放路径，window：全局设置小程序窗口的外观，tabBar：设置小程序底部的tabBar效果，style：是否启用新版的组件样式。</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931572.png" alt="image-20231126181020266" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931244.png" alt="image-20231126181141980" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置导航栏的标题：</span><br><span class="line">设置步骤：app.json-&gt;window-&gt;navigationBarTitleText</span><br><span class="line">设置导航栏的背景颜色：</span><br><span class="line">设置步骤：app.json-&gt;window-&gt;navigationBarBackgroundColor</span><br><span class="line">设置导航栏的标题颜色：</span><br><span class="line">设置步骤：app.json-&gt;window-&gt;navigationBarTextStyle</span><br><span class="line">navigationBarTextStyle的可选值只有black和white</span><br></pre></td></tr></table></figure><p><strong>全局开启下拉刷新功能：</strong></p><p>下拉刷新重新加载页面数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.json-&gt;window-&gt;把enablePullDownRefresh的值设置为true</span><br><span class="line">注意：在app.json中启用下拉刷新功能，会作用于每个小程序页面</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">全局开启下拉刷新功能后，默认的窗口背景是白色，如果自定义的下拉刷新窗口背景色，设置步骤为app.json-&gt;window-&gt;为backgroundColor设置16进制的颜色值#efefef</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">设置下拉刷新功能后，默认窗口的loading样式为白色，如果更改loading样式的效果，设置步骤为app.json-&gt;window-&gt;为backgroundTextStyle指定dark值，注意：backgroundTextStyle的可选值只有light和dark</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">设置上拉触底的距离，上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为，设置步骤：app.json-&gt;window-&gt;为onReachBottomDistance设置新的数值</span><br><span class="line">注意：默认值为50px，如果没有特殊需求，建议使用默认值即可</span><br></pre></td></tr></table></figure><h3 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h3><p>tabBar是移动端应用常见的页面，用于实现页面的快速切换，小程序里分为底部tabBar和顶部tabBar，注意：tabBar只能配置最少两个最多五个tab页签，当渲染顶部tabBar时，不显示icon，只显示文本。tabBar的文件必须放在pages中的的前面</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931860.png" alt="image-20231126190050387" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931610.png" alt="image-20231126194824606" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931560.png" alt="image-20231126194854917" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931594.png" alt="image-20231126194939462" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191931505.png" alt="image-20231126195002915" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932625.png" alt="image-20231126193411500" style="zoom:80%;" /><h2 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h2><p>app.json中的window节点，可以全局配置小程序中的每个页面的窗口表现，如某些小程序页面想要拥有特殊的窗口表现，注意：当页面配置和全局配置冲突时，根据就近原则，最终的效果以页面配置为佳。</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932877.png" alt="image-20231126200336683" style="zoom:80%;" /><h3 id="网络数据请求"><a href="#网络数据请求" class="headerlink" title="网络数据请求"></a>网络数据请求</h3><p>出于安全性只能请求https类型的接口，域名必须经过ICP备案，必须将接口的域名前加到信任列表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">配置request合法域名：</span><br><span class="line">需求描述：假设在自己的微信小程序里，希望请求https://www.escook.cn/域名下的接口</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">&lt;button bindtap=&quot;getInfo&quot;&gt;发起get请求&lt;/button&gt;</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">getInfo()&#123;</span><br><span class="line">wx.request(&#123;</span><br><span class="line">  url: &#x27;https://www.escook.cn/api/get&#x27;,</span><br><span class="line">  method:&#x27;GET&#x27;,</span><br><span class="line">  data:&#123;</span><br><span class="line">    name:&#x27;zs&#x27;,</span><br><span class="line">    age:20</span><br><span class="line">  &#125;,</span><br><span class="line">  success:(res)=&gt;&#123;</span><br><span class="line">    console.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ----------------------------------------------------------------------------</span><br><span class="line">  &lt;button bindtap=&quot;postInfo&quot;&gt;发起post请求&lt;/button&gt;</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">postInfo()&#123;</span><br><span class="line">wx.request(&#123;</span><br><span class="line">  url: &#x27;https://www.escook.cn/api/get&#x27;,</span><br><span class="line">  method:&#x27;POST&#x27;,</span><br><span class="line">  data:&#123;</span><br><span class="line">    name:&#x27;zs&#x27;,</span><br><span class="line">    age:20</span><br><span class="line">  &#125;,</span><br><span class="line">  success:(res)=&gt;&#123;</span><br><span class="line">    console.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在页面刚加载时请求数据，在页面刚加载时，自动请求一些初始化的数据，此时需要在页面的onLoad事件中调用获取数据的函数，</span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">    this.getInfo(),</span><br><span class="line">    this.postInfo()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932841.png" alt="image-20231126205559192" style="zoom: 80%;" /><h2 id="视图与逻辑"><a href="#视图与逻辑" class="headerlink" title="视图与逻辑"></a>视图与逻辑</h2><h3 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">声明式导航：在页面上声明一个&lt;navigator&gt;导航组件，通过点击这个组件实现页面跳转</span><br><span class="line">编程式导航：调用小程序的导航API，实现页面的跳转。</span><br><span class="line">=====================================================================================</span><br><span class="line">声明式导航：</span><br><span class="line">1.导航到tabBar页面：需要指定url属性和open-type属性，其中</span><br><span class="line">url为要跳转的页面的地址，必须/开头</span><br><span class="line">open-type表示跳转的方式，必须为switchTab</span><br><span class="line">2.在使用 &lt;navigator&gt; 组件跳转到普通的非 tabBar 页面时，则需要指定 url 属性和 open-type 属性，其中：</span><br><span class="line">url 表示要跳转的页面的地址，必须以 / 开头</span><br><span class="line">open-type 表示跳转的方式，必须为 navigate</span><br><span class="line">注意：为了简便，在导航到非 tabBar 页面时，open-type=&quot;navigate&quot; 属性可以省略。</span><br><span class="line">3.后退导航，如果要后退到上一页面或多级页面，则需要指定 open-type 属性和 delta 属性，其中：</span><br><span class="line"> open-type 的值必须是 navigateBack，表示要进行后退导航</span><br><span class="line"> delta 的值必须是数字，表示要后退的层级</span><br><span class="line">注意：为了简便，如果只是后退到上一页面，则可以省略 delta 属性，因为其默认值就是 1</span><br><span class="line">&lt;navigator url=&quot;/pages/message/message&quot; open-type=&quot;switchTab&quot;&gt;导航到记录页面&lt;/navigator&gt;</span><br><span class="line">&lt;navigator url=&quot;/pages/info/info&quot; open-type=&quot;navigate&quot;&gt;导航到info页面&lt;/navigator&gt;</span><br><span class="line">&lt;navigator url=&quot;/pages/info/info&quot; open-type=&quot;navigateBack&quot; delta=&quot;1&quot;&gt;导航到info页面&lt;/navigator&gt;</span><br><span class="line">=====================================================================================编程式导航：</span><br><span class="line">1.导航到tabBar页面：调用 wx.switchTab(Object object) 方法，可以跳转到 tabBar 页面。其中 Object 参数对象的属性列表如下：</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>是否必选</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>url</strong></td><td>string</td><td>是</td><td>需要跳转的 tabBar 页面的路径，路径后不能带参数</td></tr><tr><td>success</td><td>function</td><td>否</td><td>接口调用成功的回调函数</td></tr><tr><td>fail</td><td>function</td><td>否</td><td>接口调用失败的回调函数</td></tr><tr><td>complete</td><td>function</td><td>否</td><td>接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932447.png" alt="image-20231130175345084" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.导航到非tabBar页面，调用 wx.navigateTo(Object object) 方法，可以跳转到非 tabBar 的页面。其中 Object 参数对象的属性列表如下：</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>是否必选</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>url</strong></td><td>string</td><td>是</td><td>需要跳转到的非 tabBar 页面的路径，路径后可以带参数</td></tr><tr><td>success</td><td>function</td><td>否</td><td>接口调用成功的回调函数</td></tr><tr><td>fail</td><td>function</td><td>否</td><td>接口调用失败的回调函数</td></tr><tr><td>complete</td><td>function</td><td>否</td><td>接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932112.png" alt="image-20231130175324726" style="zoom: 80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.后退导航：调用 wx.navigateBack(Object object) 方法，可以返回上一页面或多级页面。其中 Object 参数对象可选的属性列表如下：</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>默认值</strong></th><th><strong>是否必选</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>delta</strong></td><td>number</td><td>1</td><td>否</td><td align="center">返回的页面数，如果 delta 大于现有页面数，则返回到首页</td></tr><tr><td>success</td><td>function</td><td></td><td>否</td><td align="center">接口调用成功的回调函数</td></tr><tr><td>fail</td><td>function</td><td></td><td>否</td><td align="center">接口调用失败的回调函数</td></tr><tr><td>complete</td><td>function</td><td></td><td>否</td><td align="center">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="页面导航-导航传参"><a href="#页面导航-导航传参" class="headerlink" title="页面导航-导航传参"></a>页面导航-导航传参</h3><h4 id="1-声明式导航传参"><a href="#1-声明式导航传参" class="headerlink" title="1.声明式导航传参"></a>1.声明式导航传参</h4><p>navigator 组件的 url 属性用来指定将要跳转到的页面的路径。同时，路径的后面还可以携带参数：</p><p>l 参数与路径之间使用 ? 分隔</p><p>l 参数键与参数值用 &#x3D; 相连</p><p>l 不同参数用 &amp; 分隔</p><p><navigator url="/pages/info/info?name=zs&age=20" open-type="navigate">导航到info页面</navigator></p><h4 id="2-编程式导航传参"><a href="#2-编程式导航传参" class="headerlink" title="2.编程式导航传参"></a>2.编程式导航传参</h4><p>调用 wx.navigateTo(Object object) 方法跳转页面时，也可以携带参数，代码示例如下：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932952.png" alt="image-20231130181653615" style="zoom:80%;" /><h4 id="3-在onLoad中接收导航参数"><a href="#3-在onLoad中接收导航参数" class="headerlink" title="3.在onLoad中接收导航参数"></a>3.在onLoad中接收导航参数</h4><p>通过声明式导航传参或编程式导航传参所携带的参数，可以直接在 onLoad 事件中直接获取到，示例代码如下</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932369.png" alt="image-20231130181702935" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data&#123;</span><br><span class="line">query:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">onLoad(options) &#123;</span><br><span class="line">    console.log(options)</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">qurey=options------接收参数到data</span><br><span class="line">&#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="页面事件"><a href="#页面事件" class="headerlink" title="页面事件"></a>页面事件</h3><h4 id="1-下拉刷新事件"><a href="#1-下拉刷新事件" class="headerlink" title="1.下拉刷新事件"></a>1.下拉刷新事件</h4><p>下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而<strong>重新加载页面数据</strong>的行为。</p><p>启用下拉刷新有两种方式：</p><p>①全局开启下拉刷新</p><p>在 app.json 的 window 节点中，将 enablePullDownRefresh 设置为 true</p><p>②局部开启下拉刷新</p><p>l在页面的 .json 配置文件中，将 enablePullDownRefresh 设置为 true在实际开发中，推荐使用第 2 种方式，为需要的页面单独开启下拉刷新的效果。</p><p>配置下拉刷新的样式：</p><p>在全局或页面的 .json 配置文件中，通过 backgroundColor 和 backgroundTextStyle 来配置下拉刷新窗口的样式，其中：</p><p>backgroundColor 用来配置下拉刷新窗口的背景颜色，仅支持16 进制的颜色值</p><p>backgroundTextStyle 用来配置下拉刷新 loading 的样式，仅支持 dark 和 light</p><p>监听页面的下拉刷新事件：</p><p>在页面的 .js 文件中，通过 <strong>onPullDownRefresh()</strong> 函数即可监听当前页面的下拉刷新事件。</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932909.png" alt="image-20231130184309989" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932049.png" alt="image-20231130184323384" style="zoom:80%;" /><p>停止下拉刷新的效果：</p><p>当处理完下拉刷新后，下拉刷新的 loading 效果会一直显示，不会主动消失，所以需要手动隐藏下拉刷新的 loading 效果。此时，调用 <strong>wx.stopPullDownRefresh()</strong> 可以停止当前页面的下拉刷新。示例代码如下：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932602.png" alt="image-20231130184419871" style="zoom:80%;" /><h4 id="4-上拉触底事件"><a href="#4-上拉触底事件" class="headerlink" title="4.上拉触底事件"></a>4.上拉触底事件</h4><p>上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而<strong>加载更多数据</strong>的行为。在页面的 .js 文件中，通过 onReachBottom() 函数即可监听当前页面的上拉触底事件。示例代码如下：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932424.png" alt="image-20231130191559683" style="zoom:80%;" /><p>设置上拉触底距离：</p><p>上拉触底距离指的是触发上拉触底事件时，滚动条距离页面底部的距离。可以在全局或页面的 .json 配置文件中，通过 onReachBottomDistance 属性来配置上拉触底的距离。小程序默认的触底距离是 50px，在实际开发中，可以根据自己的需求修改这个默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line">1.定义获取随机颜色的方法</span><br><span class="line">2.在页面加载时获取初始数据</span><br><span class="line">3.渲染 UI 结构并美化页面效果</span><br><span class="line">4.在上拉触底时调用获取随机颜色的方法</span><br><span class="line">5.添加 loading 提示效果</span><br><span class="line">6.对上拉触底进行节流处理</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期（Life Cycle）是指一个对象从创建 -&gt; 运行 -&gt; 销毁的整个阶段，强调的是一个时间段。我们可以把每个小程序运行的过程，也概括为生命周期：</p><p>小程序的启动，表示生命周期的开始</p><p>小程序的关闭，表示生命周期的结束</p><p>中间小程序运行的过程，就是小程序的生命周期</p><p><strong>生命周期的分类：</strong></p><p>在小程序中，生命周期分为两类，分别是：</p><p>① 应用生命周期：特指小程序从启动 -&gt; 运行 -&gt; 销毁的过程</p><p>② 页面生命周期：特指小程序中，每个页面的加载 -&gt; 渲染 -&gt; 销毁的过程</p><p>其中，页面的生命周期范围较小，应用程序的生命周期范围较大</p><p><strong>生命周期函数：</strong></p><p>生命周期函数：是由小程序框架提供的内置函数，会伴随着生命周期，自动按次序执行。</p><p>生命周期函数的作用：允许程序员在特定的时间点，执行某些特定的操作。例如，页面刚加载的时候，可以在 onLoad 生命周期函数中初始化页面的数据。</p><p>注意：生命周期强调的是时间段，生命周期函数强调的是时间点。</p><p><strong>生命周期函数的分类：</strong></p><p>小程序中的生命周期函数分为两类，分别是：</p><p>① 应用的生命周期函数：特指小程序从启动 -&gt; 运行 -&gt; 销毁期间依次调用的那些函数</p><p>② 页面的生命周期函数：特指小程序中，每个页面从加载 -&gt; 渲染 -&gt; 销毁期间依次调用的那些函数</p><p><strong>应用的生命周期函数：</strong></p><p>小程序的应用生命周期函数需要在 app.js 中进行声明，示例代码如下：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932302.png" alt="image-20231201182820619" style="zoom:80%;" /><p><strong>页面的生命周期函数：</strong></p><p>小程序的页面生命周期函数需要在页面的 .js 文件中进行声明，示例代码如下：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191932644.png" alt="image-20231201182849052" style="zoom:80%;" /><h3 id="wxs脚本"><a href="#wxs脚本" class="headerlink" title="wxs脚本"></a>wxs脚本</h3><p>WXS（WeiXin Script）是小程序独有的一套脚本语言，结合 WXML，可以构建出页面的结构。</p><p><strong>wxs的应用场景：</strong>wxml 中无法调用在页面的 .js 中定义的函数，但是，wxml 中可以调用 wxs 中定义的函数。因此，小程序中 wxs 的典型应用场景就是“过滤器”。</p><p><strong>wxs和javascript的关系*：</strong></p><p>虽然 wxs 的语法类似于 JavaScript，但是 wxs 和 JavaScript 是完全不同的两种语言：</p><p>①wxs 有自己的数据类型</p><p>number 数值类型、string 字符串类型、boolean 布尔类型、object 对象类型、</p><p>function 函数类型、array 数组类型、  date 日期类型、   regexp 正则</p><p>②wxs 不支持类似于 ES6 及以上的语法形式</p><p>不支持：let、const、解构赋值、展开运算符、箭头函数、对象属性简写、etc…</p><p>支持：var 定义变量、普通 function 函数等类似于 ES5 的语法</p><p>③wxs 遵循 CommonJS 规范</p><p>module 对象</p><p>require() 函数</p><p> module.exports 对象</p><p><strong>内嵌wxs脚本：</strong></p><p>wxs 代码可以编写在 wxml 文件中的 <wxs> 标签内，就像 Javascript 代码可以编写在 html 文件中的 <script> 标签内一样。</p><p>wxml 文件中的每个 <wxs></wxs> 标签，必须提供 module 属性，用来指定当前 wxs 的模块名称，方便在 wxml 中访问模块中的成员：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191933484.png" alt="image-20231201183117666" style="zoom:80%;" /><p><strong>定义外联的wxs脚本：</strong></p><p>wxs 代码还可以编写在以 .wxs 为后缀名的文件内，就像 javascript 代码可以编写在以 .js 为后缀名的文件中一样。示例代码如下：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191933527.png" alt="image-20231201183747784" style="zoom:80%;" /><p><strong>使用外联的wxs脚本：</strong></p><p>在 wxml 中引入外联的 wxs 脚本时，必须为 <wxs> 标签添加 module 和 src 属性，其中：</p><p>module 用来指定模块的名称</p><p>src 用来指定要引入的脚本的路径，且必须是相对路径</p><p>示例代码如下：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191933137.png" alt="image-20231201183928262" style="zoom:80%;" /><h4 id="wxs的特点："><a href="#wxs的特点：" class="headerlink" title="wxs的特点："></a>wxs的特点：</h4><p>1.与 JavaScript 不同，为了降低 wxs（WeiXin Script）的学习成本， wxs 语言在设计时借大量鉴了 JavaScript 的语法。但是本质上，wxs 和 JavaScript 是完全不同的两种语言！</p><p>2.不能作为组件的事件回调</p><p>wxs 典型的应用场景就是“过滤器”，经常配合 Mustache 语法进行使用，例如：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191933290.png" alt="image-20231201184130578" style="zoom:80%;" /><p>但是，在 wxs 中定义的函数不能作为组件的事件回调函数。例如，下面的用法是错误的：</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191933595.png" alt="image-20231201184150642" style="zoom:80%;" /><p>3.隔离性</p><p>隔离性指的是 wxs 的运行环境和其他 JavaScript 代码是隔离的。体现在如下两方面：</p><p>①wxs 不能调用 js 中定义的函数</p><p>②wxs 不能调用小程序提供的 API</p><p>4.性能好</p><p>在 iOS 设备上，小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍</p><p>在 android 设备上，二者的运行效率无差异</p><p>=================================================</p><h3 id="自定义组件——组件的创建和引用"><a href="#自定义组件——组件的创建和引用" class="headerlink" title="自定义组件——组件的创建和引用"></a>自定义组件——组件的创建和引用</h3><p>1.创建组件</p><p>①在项目的根目录中，鼠标右键，创建 components -> test 文件夹</p><p>②在新建的 components -> test 文件夹上，鼠标右键，点击“新建 Component”</p><p>③键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json， .wxml 和 .wxss</p><p>2.引用组件</p><p>组件的引用方式分为“局部引用”和“全局引用”，顾名思义：</p><p>局部引用：组件只能在当前被引用的页面内使用</p><p>全局引用：组件可以在每个小程序页面中使用</p><p>3.局部引用组件</p><p>在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在页面的.json文件中，引入组件。</span><br><span class="line">&#123;</span><br><span class="line">&quot;usingComponents&quot;:&#123;</span><br><span class="line">&quot;my-test1&quot;:&quot;/components/test1/test1&quot;</span><br><span class="line">&#125;&#125;</span><br><span class="line">//在页面的.wxml文件中，使用组件</span><br><span class="line">&lt;my-test1&gt;&lt;/my-test1&gt;</span><br></pre></td></tr></table></figure><p>4.全局引用组件</p><p>在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在app.json文件中，引入组件</span><br><span class="line">&#123;</span><br><span class="line">&quot;pages&quot;:[/*省略不必要的代码*/],</span><br><span class="line">&quot;window&quot;:[/*省略不必要的代码*/],</span><br><span class="line">&quot;usingComponents&quot;:&#123;</span><br><span class="line">&quot;my-test2&quot;:&quot;/components/test2/test2&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//在页面的.wxml文件中，使用组件</span><br><span class="line">&lt;my-test2&gt;&lt;/my-test2&gt;</span><br></pre></td></tr></table></figure><p>5.全局引用VS局部引用</p><p>根据组件的使用频率和范围，来选择合适的引用方式：</p><p>如果某组件在多个页面中经常被用到，建议进行“全局引用”</p><p>如果某组件只在特定的页面中被用到，建议进行“局部引用”</p><p>6.组件和页面的区别</p><p>从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与 .json 文件有明显的不同：</p><p>组件的 .json 文件中需要声明 "component": true 属性</p><p>组件的 .js 文件中调用的是 Component() 函数                 </p><p>组件的事件处理函数需要定义到 methods 节点中</p><h3 id="自定义组件——样式"><a href="#自定义组件——样式" class="headerlink" title="自定义组件——样式"></a>自定义组件——样式</h3><p>1.组件样式隔离</p><p>默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构，如图所示：</p><p>l组件 A 的样式不会影响组件 C 的样式</p><p>l组件 A 的样式不会影响小程序页面的样式</p><p>l小程序页面的样式不会影响组件 A 和 C 的样式</p><p>好处：</p><p>①防止外界的样式影响组件内部的样式</p><p>②防止组件的样式破坏外界的样式</p><p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191933443.png" alt="image-20231217233514825"></p><p>2.组件样式隔离的注意点</p><p>app.wxss 中的全局样式对组件无效</p><p>只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响</p><p>建议：在组件和引用组件的页面中建议使用 class 选择器，<strong>不要使用</strong> id、属性、标签选择器！</p><p>3.修改组件的样式隔离选项</p><p>默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。但有时，我们希望在外界能够控制组件内部的样式，此时，可以通过 styleIsolation 修改组件的样式隔离选项，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在组件的.js文件中新增如下配置</span><br><span class="line">Component(&#123;</span><br><span class="line">options：&#123;</span><br><span class="line">stylesolation：&#x27;isolated&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//或者在组件的.json文件中新增如下配置</span><br><span class="line">&#123;</span><br><span class="line">&quot;stylesolation&quot;:&quot;isolated&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.stylesolation的可选值</p><table><thead><tr><th align="left"><strong>可选值</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">isolated</td><td>是</td><td>表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响</td></tr><tr><td align="left">apply-shared</td><td>否</td><td>表示页面 wxss  样式将影响到自定义组件，但自定义组件  wxss  中指定的样式不会影响页面</td></tr><tr><td align="left">shared</td><td>否</td><td>表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件</td></tr></tbody></table><h3 id="自定义组件——数据、方法和属性"><a href="#自定义组件——数据、方法和属性" class="headerlink" title="自定义组件——数据、方法和属性"></a>自定义组件——数据、方法和属性</h3><p>1.data数据</p><p>在小程序组件中，用于组件模板渲染的私有数据，需要定义到 data 节点中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">data:&#123;</span><br><span class="line">count:0</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.methods方法</p><p>在小程序组件中，事件处理函数和自定义方法需要定义到 methods 节点中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">methods&#123;//组件的方法列表，包含事件处理函数和自定义方法</span><br><span class="line">addCount()&#123;//事件处理函数</span><br><span class="line">this.setData(&#123;count:this.data.count+1&#125;)</span><br><span class="line">this.showCount()//通过this直接调用自定义方法</span><br><span class="line">&#125;,</span><br><span class="line">_showCount()&#123;//自定义方法建议_开头</span><br><span class="line">wx.showToast(&#123;</span><br><span class="line">title:&#x27;count值为&#x27;+this.data.count,</span><br><span class="line">icon:&#x27;none&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.properties属性</p><p>在小程序组件中，properties 是组件的对外属性，用来接收外界传递到组件中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">properties:&#123;</span><br><span class="line">max:&#123;//完整定义属性的方法，当需要指定属性默认值的时候，建议使用此方法</span><br><span class="line">type:Number,</span><br><span class="line">value:10</span><br><span class="line">&#125;,</span><br><span class="line">max:Number//简化定义属性的方法，不需要指定属性默认值的时候，使用简化方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">&lt;my-test1 max=&#x27;10&#x27;&gt;&lt;/my-test1&gt;</span><br></pre></td></tr></table></figure><p>4.data和properties的区别</p><p>在小程序的组件中，properties 属性和 data 数据的用法相同，它们都是可读可写的，只不过：</p><p>data 更倾向于存储组件的私有数据</p><p>properties 更倾向于存储外界传递到组件中的数据</p><img src="https://cdn.jsdelivr.net/gh/Arrebolzy1127/tupianku/img/202312191933505.png" alt="image-20231218104453060" style="zoom:80%;" /><p>5.使用setData修改properties的值</p><p>由于 data 数据和 properties 属性在本质上没有任何区别，因此 properties 属性的值也可以用于页面渲染，或使用 setData 为 properties 中的属性重新赋值，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在组件的.wxml文件中使用properties属性的值</span><br><span class="line">&lt;view&gt;max属性的值为：&#123;&#123;max&#125;&#125;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">Component(&#123;</span><br><span class="line">properties:&#123;max:Number&#125;,//定义属性</span><br><span class="line">methods:&#123;</span><br><span class="line">addCount()&#123;</span><br><span class="line">this.setData(&#123;max:this.properties.max+1&#125;)//使用setData修改属性的值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义组件——数据监听器"><a href="#自定义组件——数据监听器" class="headerlink" title="自定义组件——数据监听器"></a>自定义组件——数据监听器</h3><p>数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。它的作用类似于 vue 中的 watch 侦听器。在小程序组件中，数据监听器的基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">obervers:&#123;</span><br><span class="line">&#x27;字段A，字段B&#x27;:function(字段A的新值,字段B的新值)&#123;</span><br><span class="line">//do something</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>1.数据监听器的基本用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//组件的UI结构如下</span><br><span class="line">&lt;view&gt;&#123;&#123;n1&#125;&#125;+&#123;&#123;n2&#125;&#125;=&#123;&#123;sum&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;button size=&quot;mini&quot; bindtap=&#x27;addN1&#x27;&gt;n1自增&lt;button&gt;</span><br><span class="line">&lt;button size=&quot;mini&quot; bindtap=&#x27;addN2&#x27;&gt;n2自增&lt;button&gt;</span><br><span class="line"></span><br><span class="line">//组件的js代码</span><br><span class="line">Component(&#123;</span><br><span class="line">data:&#123;n1:0,n2:0,sum:0&#125;//数据节点</span><br><span class="line">methods:&#123;//方法列表</span><br><span class="line">addN1()&#123;this.setData(&#123;n1:this.data.n1+1&#125;)&#125;,</span><br><span class="line">addN2()&#123;this.setData(&#123;n2:this.data.n2+1&#125;)&#125;</span><br><span class="line">&#125;,</span><br><span class="line">obervers&#123;//数据监听节点</span><br><span class="line">&#x27;n1,n2&#x27;:function(n1,n2)&#123;//监听n1和n2的数据的变化</span><br><span class="line">this.setData(&#123;sum:n1+n2&#125;)//通过监听器，自动计算sum的值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/12/03/hello-world/"/>
      <url>/2023/12/03/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
